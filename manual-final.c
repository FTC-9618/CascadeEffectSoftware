#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     leftside,       sensorNone)
#pragma config(Sensor, S2,     rightside,      sensorNone)
#pragma config(Motor,  mtr_S1_C1_1,     frontRight,    tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     backRight,     tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     backLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_1,     manipright,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     manipleft,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    armmanip1,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    armmanip2,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    gatemanip,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#pragma DebuggerWindows("joystickSimple")



/*Last edited Feb 10, most current version*/

/*
Mecanum drive with Deadsone thresholds, gives the driver room for error when centering circle pads
		-Left circle-pad
				y-axis moves robot along y-axis
				x-axis moves robot along x-axis
					diagonally uses both axis'
		-Right circle-pad
				x-axis rotate robot
				y-axis move manip up and down
		-Buttons
				Btn(1) = ( X )
					move hand-part up
				Btn(4) = ( Y )
					move hand-part down
				Btn(2) = ( A )
					move gate-grabber up
				Btn(3) = ( B )
					move gate-grabber down
*/
int transX, transY, rot;

void mecanumDrive(int transX, int transY, int rot) {
		motor[frontRight] = transY - rot - transX;
		motor[backRight] = transY - rot + transX;
		motor[frontLeft] = transY + rot + transX;
		motor[backLeft] = transY + rot - transX;
	}

task main()
{
	// main tele-op loop
	while(true) {

	//movement code
		getJoystickSettings(joystick);

		transX = joystick.joy1_x1;
		transY = joystick.joy1_y1;
		rot = joystick.joy1_x2;

		mecanumDrive(transX, transY, rot);

	//arm up and down code
		if(joystick.joy1_y2){
      motor[manipright] = joystick.joy1_y2;
      motor[manipleft] = joystick.joy1_y2;

  //manip movement code
  	if(joy1Btn(1) == true){
  		servo[armmanip1] = 100;
  		servo[armmanip2] = -100;
		}
  	else(joy1Btn(4) == true);{
  		servo[armmanip1] = -100;
  		servo[armmanip2] = 100;
  	}

  //goal code
  	if(joy1Btn(2) == true){
  		servo[gatemanip] = 50;
  	}
  	else(joy1Btn(3) == true);{
  		servo[gatemanip] = -50;
		}
	}
}
}
