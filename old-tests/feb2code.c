#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     leftside,       sensorI2CMuxController)
#pragma config(Sensor, S2,     rightside,      sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     frontRight,    tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     backRight,     tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     backLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    mainmanip1,           tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    mainmanip2,           tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**!!Code automatically generated by 'ROBOTC' configuration wizard               !!*/

#include "JoystickDriver.c"
#pragma DebuggerWindows("joystickSimple")
/**!!Code automatically generated by 'ROBOTC' configuration wizard               !!*/



/*Last edited Feb 3, most current version*/



/*
Mecanum drive with Deadsone thresholds, gives the driver room for error when centering circle pads
		-Left circle-pad
				y-axis moves robot along y-axis
				x-axis moves robot along x-axis
					diagonally uses both axis'
		-Right circle-pad
				rotate robot according to x-axis
*/

void mecanumDrive(int transX, int transY, int rot) {

		motor[frontRight] = transY - rot - transX;
		motor[backRight] = transY - rot + transX;
		motor[frontLeft] = transY + rot + transX;
		motor[backLeft] = transY + rot - transX;
	}

task main()
{
	int transX, transY, rot;
int manipServoSpeed = 10;
int manipServoRate = 0;
int mainmanip1val, mainmanip2val;
	// main tele-op loop
	while(true) {
		getJoystickSettings(joystick);
		transX = joystick.joy1_x1;
		transY = joystick.joy1_y1;
		rot = joystick.joy1_x2;

		mecanumDrive(transX, transY, rot);

	getJoystickSettings(joystick);
	manipServoRate = manipServoRate + (joystick.joy1_y2/manipServoSpeed);
	//mainmanip1val =


	//servo[mainmanip1] = mainmanip1val;
	//servo[mainmanip2] = mainmanip2val;
	}
	/*
	while(true)
{
	startTask(getHeading);
  startTask(getIR);

    waitForStart();
      do {
					mecanumDrive(tansX, transY, rot);

        if (irExists) { //if it sees a beacon after turning,
            beaconIsFound = true; //end the search loop.
        }
    } while (!beaconIsFound && counter < 3); //stop when Samantha finds beacon
  }
  */
}
