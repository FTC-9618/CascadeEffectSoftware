#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Mecanum drive with Deadsone thresholds, gives the driver room for error when centering circle pads
		-Left circle-pad
				y-axis moves robot along y-axis
				x-axis moves robot along x-axis
					diagonally uses both axis'
		-Right circle-pad
				rotate robot according to x-axis
*/
task main()
{
	/*Deadzone code*/
int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;
	while(1 == 1)
	{
	if(abs(vexRT[Ch3]) > threshold)
		Y1 = vexRT[Ch3];
	else
		Y1 = 0;
	if(abs(vexRT[Ch4]) > threshold)
		X1 = vexRT[Ch4];
	else
		X1 = 0;
	if (abs(vexRT[Ch1]) > threshold)
		X2 = vexRT[Ch1];
	else
		X2 = 0;

/*Movement with joystick*/
	motor[frontRight] = Y1 - X2 - X1;
	motor[backRight] = Y1 - X2 +X1;
	motor[frontLeft] = Y1 + X2 + X1;
	motor[backLeft] = Y1 + X2 - X1;
	}
}
